package com.hebit.app.ui.screens.tasks

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.hebit.app.domain.model.Resource
import com.hebit.app.domain.model.Task
import com.hebit.app.domain.repository.TaskRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import java.time.LocalDateTime
import javax.inject.Inject

@HiltViewModel
class TaskViewModel @Inject constructor(
    private val taskRepository: TaskRepository
) : ViewModel() {
    
    private val _tasksState = MutableStateFlow<Resource<List<Task>>>(Resource.Loading())
    val tasksState: StateFlow<Resource<List<Task>>> = _tasksState.asStateFlow()
    
    private val _priorityTasksState = MutableStateFlow<Resource<List<Task>>>(Resource.Loading())
    val priorityTasksState: StateFlow<Resource<List<Task>>> = _priorityTasksState.asStateFlow()
    
    private val _todayTasksState = MutableStateFlow<Resource<List<Task>>>(Resource.Loading())
    val todayTasksState: StateFlow<Resource<List<Task>>> = _todayTasksState.asStateFlow()
    
    private val _selectedTaskState = MutableStateFlow<Resource<Task?>>(Resource.Success(null))
    val selectedTaskState: StateFlow<Resource<Task?>> = _selectedTaskState.asStateFlow()
    
    init {
        loadTasks()
    }
    
    fun loadTasks() {
        viewModelScope.launch {
            taskRepository.getTasks()
                .onEach { result ->
                    _tasksState.value = result
                }
                .launchIn(this)
        }
    }
    
    fun loadPriorityTasks(limit: Int = 5) {
        viewModelScope.launch {
            taskRepository.getPriorityTasks(limit)
                .onEach { result ->
                    _priorityTasksState.value = result
                }
                .launchIn(this)
        }
    }
    
    fun loadTodayTasks() {
        viewModelScope.launch {
            taskRepository.getTasksDueToday()
                .onEach { result ->
                    _todayTasksState.value = result
                }
                .launchIn(this)
        }
    }
    
    fun getTaskById(id: String) {
        viewModelScope.launch {
            taskRepository.getTaskById(id)
                .onEach { result ->
                    _selectedTaskState.value = result as Resource<Task?>
                }
                .launchIn(this)
        }
    }
    
    fun createTask(
        title: String,
        description: String,
        category: String,
        dueDateTime: LocalDateTime?,
        priority: Int
    ) {
        val newTask = Task(
            id = "", // Will be generated by the backend
            title = title,
            description = description,
            category = category,
            dueDateTime = dueDateTime,
            priority = priority,
            progress = 0,
            isCompleted = false,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now()
        )
        
        viewModelScope.launch {
            taskRepository.createTask(newTask)
                .onEach { result ->
                    if (result is Resource.Success) {
                        loadTasks()
                    }
                }
                .launchIn(this)
        }
    }
    
    fun updateTask(task: Task) {
        viewModelScope.launch {
            taskRepository.updateTask(task)
                .onEach { result ->
                    if (result is Resource.Success) {
                        loadTasks()
                        _selectedTaskState.value = Resource.Success(result.data)
                    }
                }
                .launchIn(this)
        }
    }
    
    fun updateTaskCompletion(task: Task, isCompleted: Boolean) {
        val updatedTask = task.copy(
            isCompleted = isCompleted,
            updatedAt = LocalDateTime.now()
        )
        
        updateTask(updatedTask)
    }
    
    fun updateTaskProgress(task: Task, progress: Int) {
        val updatedTask = task.copy(
            progress = progress,
            updatedAt = LocalDateTime.now()
        )
        
        updateTask(updatedTask)
    }
    
    fun deleteTask(id: String) {
        viewModelScope.launch {
            taskRepository.deleteTask(id)
                .onEach { result ->
                    if (result is Resource.Success && result.data == true) {
                        loadTasks()
                        _selectedTaskState.value = Resource.Success(null)
                    }
                }
                .launchIn(this)
        }
    }
    
    fun clearSelectedTask() {
        _selectedTaskState.value = Resource.Success(null)
    }
} 